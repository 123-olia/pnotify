"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* src/PNotify.html generated by Svelte v1.40.0 */
var PNotify = function () {
  "use strict";

  var PNotify = void 0;

  var defaultStack = {
    dir1: "down",
    dir2: "left",
    push: "bottom",
    spacing1: 36,
    spacing2: 36,
    context: window && document.body,
    modal: false
  };
  var posTimer = void 0; // Position all timer.
  // Set global variables.
  var onDocumentLoaded = function onDocumentLoaded() {
    defaultStack.context = document.body;
    // Reposition the notices when the window resizes.
    window.addEventListener('resize', function () {
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = setTimeout(function () {
        PNotify.positionAll(true);
      }, 10);
    });
  };
  var createStackOverlay = function createStackOverlay(stack) {
    var overlay = document.createElement("div");
    overlay.classList.add("ui-pnotify-modal-overlay");
    stack.context.insertBefore(overlay, stack.context.firstChild);
    // Close the notices on overlay click.
    overlay.addEventListener('click', function () {
      if (stack.overlay_close) {
        PNotify.removeStack(stack);
      }
    });
    return overlay;
  };

  function _text_processed(text, insert_brs) {
    return insert_brs ? String(text).replace(/\n/g, '<br />') : text;
  }

  function _styles(styling) {
    return (typeof styling === "undefined" ? "undefined" : _typeof(styling)) === "object" ? styling : PNotify.styling[styling];
  }

  function data() {
    return _extends({
      "_state": "initializing", // The state can be "initializing", "opening", "open", "closing", and "closed".
      "_timer": null, // Auto close timer.
      "_animTimer": null, // Animation timer.
      "_animating": false, // Stores what is currently being animated (in or out).
      "_animatingClass": "", // Stores the class that adds entry/exit animation effects.
      "_moveClass": "", // Stores the class that adds movement animation effects.
      "_timerHide": false // Stores whether the notice was hidden by a timer.
    }, PNotify.defaults);
  };

  var methods = {
    // This runs an event on all the modules.
    runModules: function runModules(event, arg) {
      var modules = this.get("_modules");
      for (var module in modules) {
        var curArg = (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && module in arg ? arg[module] : arg;
        if (typeof modules[module][event] === 'function') {
          modules[module].notice = this;
          modules[module].options = _typeof(this.get("modules")[module]) === 'object' ? this.get("modules")[module] : {};
          modules[module][event](this, _typeof(this.get("modules")[module]) === 'object' ? this.get("modules")[module] : {}, curArg);
        }
      }
    },
    update: function update(options) {
      // Save old options.
      var oldHide = this.get("hide");

      // Run the modules.
      this.runModules('update', options);

      this.set(options);

      // Update the timed hiding.
      if (!this.get("hide")) {
        this.cancelRemove();
      } else if (!oldHide) {
        this.queueRemove();
      }
      this.queuePosition(true);

      return this;
    },
    mouseenter: function mouseenter(e) {
      // Stop animation, reset the removal timer when the user mouses over.
      if (this.get("mouse_reset") && this.get("_animating") === "out") {
        if (!this.get("_timerHide")) {
          return;
        }
        this.cancelRemove();
      }
      // Stop the close timer.
      if (this.get("hide") && this.get("mouse_reset")) {
        this.cancelRemove();
      }
    },
    mouseleave: function mouseleave(e) {
      // Start the close timer.
      if (this.get("hide") && this.get("mouse_reset") && this.get("_animating") !== "out") {
        this.queueRemove();
      }
      PNotify.positionAll();
    },


    // Display the notice.
    open: function open() {
      var _this = this;

      this.set({ "_state": "opening" });
      // Run the modules.
      this.runModules('beforeOpen');

      var stack = this.get("stack");
      // If the notice is not in the DOM, append it.
      if (!this.refs.elem.parentNode) {
        if (stack.context) {
          stack.context.appendChild(this.refs.elem);
        } else if (document.body) {
          document.body.appendChild(this.refs.elem);
        } else {
          throw new Error("No context to open this notice in.");
        }
      }
      // Try to put it in the right position.
      if (stack.push !== "top") {
        this.position(true);
      }
      this.animateIn(function () {
        _this.queuePosition(true);

        // Now set it to hide.
        if (_this.get("hide")) {
          _this.queueRemove();
        }

        _this.set({ "_state": "open" });

        // Run the modules.
        _this.runModules('afterOpen');
      });

      return this;
    },


    // Remove the notice.
    remove: function remove(timerHide) {
      var _this2 = this;

      this.set({ "_state": "closing", "_timerHide": !!timerHide }); // Make sure it's a boolean.
      // Run the modules.
      this.runModules('beforeClose');

      if (this.get("_timer") && clearTimeout) {
        clearTimeout(this.get("_timer"));
        this.set({ "_timer": null });
      }
      this.animateOut(function () {
        _this2.set({ "_state": "closed" });
        // Run the modules.
        _this2.runModules('afterClose');
        _this2.queuePosition(true);
        // If we're supposed to remove the notice from the DOM, do it.
        if (_this2.get("remove")) {
          _this2.refs.elem.parentNode.removeChild(_this2.refs.elem);
        }
        // Run the modules.
        _this2.runModules('beforeDestroy');
        // Remove object from PNotify.notices to prevent memory leak (issue #49)
        // unless destroy is off
        if (_this2.get("destroy")) {
          if (PNotify.notices !== null) {
            var idx = PNotify.notices.indexOf(_this2);
            if (idx !== -1) {
              PNotify.notices.splice(idx, 1);
            }
          }
        }
        // Run the modules.
        _this2.runModules('afterDestroy');
      });

      return this;
    },


    // Animate the notice in.
    animateIn: function animateIn(callback) {
      var _this3 = this;

      // Declare that the notice is animating in.
      this.set({ "_animating": "in" });
      var finished = function finished() {
        _this3.refs.elem.removeEventListener('transitionend', finished);
        if (_this3.get("_animTimer")) {
          clearTimeout(_this3.get("_animTimer"));
        }
        if (_this3.get("_animating") !== "in") {
          return;
        }
        var visible = false;
        var domRect = _this3.refs.elem.getBoundingClientRect();
        for (var prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
        if (visible) {
          if (callback) {
            callback.call();
          }
          // Declare that the notice has completed animating.
          _this3.set({ "_animating": false });
        } else {
          _this3.set({ "_animTimer": setTimeout(finished, 40) });
        }
      };

      if (this.get("animation") === "fade") {
        this.refs.elem.addEventListener('transitionend', finished);
        this.set({ "_animatingClass": "ui-pnotify-in" });
        this.refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.
        this.set({ "_animatingClass": "ui-pnotify-in ui-pnotify-fade-in" });
        // Just in case the event doesn't fire, call it after 650 ms.
        this.set({ "_animTimer": setTimeout(finished, 650) });
      } else {
        this.set({ "_animatingClass": "ui-pnotify-in" });
        finished();
      }
    },


    // Animate the notice out.
    animateOut: function animateOut(callback) {
      var _this4 = this;

      // Declare that the notice is animating out.
      this.set({ "_animating": "out" });
      var finished = function finished() {
        _this4.refs.elem.removeEventListener('transitionend', finished);
        if (_this4.get("_animTimer")) {
          clearTimeout(_this4.get("_animTimer"));
        }
        if (_this4.get("_animating") !== "out") {
          return;
        }
        var visible = false;
        var domRect = _this4.refs.elem.getBoundingClientRect();
        for (var prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
        if (!_this4.refs.elem.style.opacity || _this4.refs.elem.style.opacity == "0" || !visible) {
          _this4.set({ "_animatingClass": "" });
          var stack = _this4.get("stack");
          if (stack.overlay) {
            // Go through the modal stack to see if any are left open.
            // TODO: Rewrite this cause it sucks.
            var stillOpen = false;
            for (var i = 0; i < PNotify.notices.length; i++) {
              var notice = PNotify.notices[i];
              if (notice != _this4 && notice.get("stack") === stack && notice.get("_state") !== "closed") {
                stillOpen = true;
                break;
              }
            }
            if (!stillOpen) {
              stack.overlay.classList.add("ui-pnotify-modal-overlay-hidden");
            }
          }
          if (callback) {
            callback.call();
          }
          // Declare that the notice has completed animating.
          _this4.set({ "_animating": false });
        } else {
          // In case this was called before the notice finished animating.
          _this4.set({ "_animTimer": setTimeout(finished, 40) });
        }
      };

      if (this.get("animation") === "fade") {
        this.refs.elem.addEventListener('transitionend', finished);
        this.set({ "_animatingClass": "ui-pnotify-in" });
        // Just in case the event doesn't fire, call it after 650 ms.
        this.set({ "_animTimer": setTimeout(finished, 650) });
      } else {
        this.set({ "_animatingClass": "" });
        finished();
      }
    },


    // Position the notice. dont_skip_hidden causes the notice to
    // position even if it's not visible.
    position: function position(dontSkipHidden) {
      // Get the notice's stack.
      var stack = this.get("stack"),
          elem = this.refs.elem;
      if (!stack) {
        return;
      }
      if (!stack.context) {
        stack.context = document.body;
      }
      if (typeof stack.nextpos1 !== "number") {
        stack.nextpos1 = stack.firstpos1;
      }
      if (typeof stack.nextpos2 !== "number") {
        stack.nextpos2 = stack.firstpos2;
      }
      if (typeof stack.addpos2 !== "number") {
        stack.addpos2 = 0;
      }
      var hidden = !elem.classList.contains("ui-pnotify-in");
      console.log("hidden: ", hidden);
      console.log("dontSkipHidden: ", dontSkipHidden);
      // Skip this notice if it's not shown.
      if (!hidden || dontSkipHidden) {
        if (stack.modal) {
          if (stack.overlay) {
            stack.overlay.classList.remove("ui-pnotify-modal-overlay-hidden");
          } else {
            stack.overlay = createStackOverlay(stack);
          }
        }

        // If the notice is hidden, and there is no firstpos settings, we
        // should skip it even if we're told not to, because it will just be
        // positioned into the corner.
        // if ((typeof stack.firstpos1 === "undefined" || typeof stack.firstpos2 === "undefined") && hidden) {
        //   return;
        // }

        var domRect = elem.getBoundingClientRect();
        // Add animate class by default.
        this.set({ "_moveClass": "ui-pnotify-move" });
        var curpos1 = void 0,
            curpos2 = void 0;

        // Calculate the current pos1 value.
        var csspos1 = void 0;
        switch (stack.dir1) {
          case "down":
            csspos1 = "top";
            curpos1 = elem.offsetTop;
            break;
          case "up":
            csspos1 = "bottom";
            curpos1 = elem.offsetParent ? (stack.context === document.body ? window.innerHeight : stack.context.scrollHeight) - elem.scrollHeight - elem.offsetTop : 0;
            break;
          case "left":
            csspos1 = "right";
            curpos1 = elem.offsetParent ? (stack.context === document.body ? window.innerWidth : stack.context.scrollWidth) - elem.scrollWidth - elem.offsetLeft : 0;
            break;
          case "right":
            csspos1 = "left";
            curpos1 = elem.offsetLeft;
            break;
        }
        // Remember the first pos1, so the first notice goes there.
        if (typeof stack.firstpos1 === "undefined" && (curpos1 !== 0 || !hidden)) {
          stack.firstpos1 = curpos1;
          stack.nextpos1 = stack.firstpos1;
        }

        // Calculate the current pos2 value.
        var csspos2 = void 0;
        switch (stack.dir2) {
          case "down":
            csspos2 = "top";
            curpos2 = elem.offsetTop;
            break;
          case "up":
            csspos2 = "bottom";
            curpos2 = elem.offsetParent ? (stack.context === document.body ? window.innerHeight : stack.context.scrollHeight) - elem.scrollHeight - elem.offsetTop : 0;
            break;
          case "left":
            csspos2 = "right";
            curpos2 = elem.offsetParent ? (stack.context === document.body ? window.innerWidth : stack.context.scrollWidth) - elem.scrollWidth - elem.offsetLeft : 0;
            break;
          case "right":
            csspos2 = "left";
            curpos2 = elem.offsetLeft;
            break;
        }
        // Remember the first pos2, so the first notice goes there.
        if (typeof stack.firstpos2 === "undefined" && (curpos2 !== 0 || !hidden)) {
          stack.firstpos2 = curpos2;
          stack.nextpos2 = stack.firstpos2;
        }

        // Check that it's not beyond the viewport edge.
        var endY = stack.nextpos1 + elem.offsetHeight + (typeof stack.spacing1 === "undefined" ? 25 : stack.spacing1),
            endX = stack.nextpos1 + elem.offsetWidth + (typeof stack.spacing1 === "undefined" ? 25 : stack.spacing1),
            spaceY = stack.context === document.body ? window.innerHeight : stack.context.scrollHeight,
            spaceX = stack.context === document.body ? window.innerWidth : stack.context.scrollWidth;
        if ((stack.dir1 === "down" || stack.dir1 === "up") && endY > spaceY || (stack.dir1 === "left" || stack.dir1 === "right") && endX > spaceX) {
          // If it is, it needs to go back to the first pos1, and over on pos2.
          stack.nextpos1 = stack.firstpos1;
          stack.nextpos2 += stack.addpos2 + (typeof stack.spacing2 === "undefined" ? 25 : stack.spacing2);
          stack.addpos2 = 0;
        }

        // Move the notice on dir2.
        console.log("stack.nextpos2: ", stack.nextpos2);
        if (typeof stack.nextpos2 === "number") {
          if (!stack.animation) {
            this.set({ "_moveClass": "" });
            elem.style[csspos2] = stack.nextpos2 + "px";
            elem.style[csspos2]; // Read from the DOM for update.
            this.set({ "_moveClass": "ui-pnotify-move" });
          } else {
            elem.style[csspos2] = stack.nextpos2 + "px";
          }
        }

        // Keep track of the widest/tallest notice in the column/row, so we can push the next column/row.
        switch (stack.dir2) {
          case "down":
          case "up":
            if (elem.offsetHeight + (parseFloat(elem.style.marginTop, 10) || 0) + (parseFloat(elem.style.marginBottom, 10) || 0) > stack.addpos2) {
              stack.addpos2 = elem.offsetHeight;
            }
            break;
          case "left":
          case "right":
            if (elem.offsetWidth + (parseFloat(elem.style.marginLeft, 10) || 0) + (parseFloat(elem.style.marginRight, 10) || 0) > stack.addpos2) {
              stack.addpos2 = elem.offsetWidth;
            }
            break;
        }

        // Move the notice on dir1.
        console.log("stack.nextpos1: ", stack.nextpos1);
        if (typeof stack.nextpos1 === "number") {
          if (!stack.animation) {
            this.set({ "_moveClass": "" });
            elem.style[csspos1] = stack.nextpos1 + "px";
            elem.style[csspos1]; // Read from the DOM for update.
            this.set({ "_moveClass": "ui-pnotify-move" });
          } else {
            elem.style[csspos1] = stack.nextpos1 + "px";
          }
        }
        // Calculate the next dir1 position.
        switch (stack.dir1) {
          case "down":
          case "up":
            stack.nextpos1 += elem.offsetHeight + (typeof stack.spacing1 === "undefined" ? 25 : stack.spacing1);
            break;
          case "left":
          case "right":
            stack.nextpos1 += elem.offsetWidth + (typeof stack.spacing1 === "undefined" ? 25 : stack.spacing1);
            break;
        }
      }
      return this;
    },


    // Queue the position all function so it doesn't run repeatedly and
    // use up resources.
    queuePosition: function queuePosition(animate, milliseconds) {
      if (posTimer) {
        clearTimeout(posTimer);
      }
      if (!milliseconds) {
        milliseconds = 10;
      }
      posTimer = setTimeout(function () {
        PNotify.positionAll(animate);
      }, milliseconds);
      return this;
    },


    // Cancel any pending removal timer.
    cancelRemove: function cancelRemove() {
      if (this.get("_timer")) {
        clearTimeout(this.get("_timer"));
      }
      if (this.get("_animTimer")) {
        clearTimeout(this.get("_animTimer"));
      }
      if (this.get("_state") === "closing") {
        // If it's animating out, stop it.
        this.set({
          "_state": "open",
          "_animating": false,
          "_animatingClass": this.get("animation") === "fade" ? "ui-pnotify-in ui-pnotify-fade-in" : "ui-pnotify-in"
        });
      }
      return this;
    },


    // Queue a removal timer.
    queueRemove: function queueRemove() {
      var _this5 = this;

      // Cancel any current removal timer.
      this.cancelRemove();
      this.set({
        "_timer": setTimeout(function () {
          return _this5.remove(true);
        }, isNaN(this.get("delay")) ? 0 : this.get("delay"))
      });
      return this;
    }
  };

  function oncreate() {
    // We don't want our module objects all referencing the main object.
    var modules = {};
    for (var m in PNotify.modules) {
      if (!PNotify.modules.hasOwnProperty(m)) {
        continue;
      }
      modules[m] = _extends({}, PNotify.modules[m]);
    }
    this.set({ "_modules": modules });

    // Add the notice to the notice array.
    if (this.get("stack").push === "top") {
      PNotify.notices.splice(0, 0, this);
      // Now position all the notices if they are to push to the top.
      this.queuePosition(false, 1);
    } else {
      PNotify.notices.push(this);
    }

    // Mark the stack so it won't animate the new notice.
    this.get("stack").animation = false;

    // Run the modules.
    this.runModules('init');

    // We're now initialized, but haven't been opened yet.
    this.set({ "_state": "closed" });

    // Display the notice.
    if (this.get("auto_display")) {
      this.open();
    }
  };

  function setup(Component) {
    PNotify = Component;
    PNotify.VERSION = "4.0.0-dev";

    PNotify.defaults = {
      // The notice's title.
      title: false,
      // Whether to escape the content of the title. (Not allow HTML.)
      title_escape: false,
      // The notice's text.
      text: false,
      // Whether to escape the content of the text. (Not allow HTML.)
      text_escape: false,
      // What styling classes to use. (Can be either "brighttheme", "bootstrap3", "fontawesome", or a styling object.)
      styling: "brighttheme",
      // Additional classes to be added to the notice. (For custom styling.)
      addclass: "",
      // Class to be added to the notice for corner styling.
      cornerclass: "",
      // Display the notice when it is created.
      auto_display: true,
      // Width of the notice.
      width: "300px",
      // Minimum height of the notice. It will expand to fit content.
      min_height: "16px",
      // Type of the notice. "notice", "info", "success", or "error".
      type: "info",
      // Set icon to true to use the default icon for the selected
      // style/type, false for no icon, or a string for your own icon class.
      icon: true,
      // The animation to use when displaying and hiding the notice. "none"
      // and "fade" are supported through CSS. Others are supported
      // through the Animate module and Animate.css.
      animation: "fade",
      // Speed at which the notice animates in and out. "slow", "normal",
      // or "fast". Respectively, 400ms, 250ms, 100ms.
      animate_speed: "normal",
      // Display a drop shadow.
      shadow: true,
      // After a delay, remove the notice.
      hide: true,
      // Delay in milliseconds before the notice is removed.
      delay: 8000,
      // Reset the hide timer if the mouse moves over the notice.
      mouse_reset: true,
      // Remove the notice's elements from the DOM after it is removed.
      remove: true,
      // Change new lines to br tags.
      insert_brs: true,
      // Whether to remove the notice from the global array when it is closed.
      destroy: true,
      // The stack on which the notices will be placed. Also controls the
      // direction the notices stack.
      stack: defaultStack,
      // This is where options for modules should be defined.
      modules: {}
    };

    // An array of all active notices.
    PNotify.notices = [];
    // This object holds all the PNotify modules. They are used to provide
    // additional functionality.
    PNotify.modules = {};

    PNotify.alert = function (options) {
      return new PNotify({ target: document.body, data: options });
    };

    PNotify.notice = function (options) {
      options.type = "notice";
      return new PNotify({ target: document.body, data: options });
    };

    PNotify.info = function (options) {
      options.type = "info";
      return new PNotify({ target: document.body, data: options });
    };

    PNotify.success = function (options) {
      options.type = "success";
      return new PNotify({ target: document.body, data: options });
    };

    PNotify.error = function (options) {
      options.type = "error";
      return new PNotify({ target: document.body, data: options });
    };

    PNotify.removeAll = function () {
      for (var i = 0; i < PNotify.notices.length; i++) {
        if (PNotify.notices[i].remove) {
          PNotify.notices[i].remove(false);
        }
      }
    };
    PNotify.removeStack = function (stack) {
      for (var i = 0; i < PNotify.notices.length; i++) {
        if (PNotify.notices[i].remove && PNotify.notices[i].get("stack") === stack) {
          PNotify.notices[i].remove(false);
        }
      }
    };
    PNotify.positionAll = function (animate) {
      // This timer is used for queueing this function so it doesn't run
      // repeatedly.
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = null;
      // Reset the next position data.
      if (PNotify.notices.length > 0) {
        for (var i = 0; i < PNotify.notices.length; i++) {
          var notice = PNotify.notices[i],
              s = notice.get("stack");
          if (!s) {
            return;
          }
          if (s.overlay) {
            s.overlay.classList.add("ui-pnotify-modal-overlay-hidden");
          }
          s.nextpos1 = s.firstpos1;
          s.nextpos2 = s.firstpos2;
          s.addpos2 = 0;
          s.animation = animate;
        }
        for (var _i = 0; _i < PNotify.notices.length; _i++) {
          PNotify.notices[_i].position();
        }
      } else {
        delete defaultStack.nextpos1;
        delete defaultStack.nextpos2;
      }
    };

    PNotify.styling = {
      brighttheme: {
        // Bright Theme doesn't require any UI libraries.
        container: "brighttheme",
        notice: "brighttheme-notice",
        notice_icon: "brighttheme-icon-notice",
        info: "brighttheme-info",
        info_icon: "brighttheme-icon-info",
        success: "brighttheme-success",
        success_icon: "brighttheme-icon-success",
        error: "brighttheme-error",
        error_icon: "brighttheme-icon-error"
      },
      bootstrap3: {
        container: "alert",
        notice: "alert-warning",
        notice_icon: "glyphicon glyphicon-exclamation-sign",
        info: "alert-info",
        info_icon: "glyphicon glyphicon-info-sign",
        success: "alert-success",
        success_icon: "glyphicon glyphicon-ok-sign",
        error: "alert-danger",
        error_icon: "glyphicon glyphicon-warning-sign"
      }
    };
    /*
     * uses icons from http://fontawesome.io/
     * version 4.0.3
     */
    PNotify.styling.fontawesome = _extends({}, PNotify.styling.bootstrap3);
    _extends(PNotify.styling.fontawesome, {
      notice_icon: "fa fa-exclamation-circle",
      info_icon: "fa fa-info",
      success_icon: "fa fa-check",
      error_icon: "fa fa-warning"
    });

    if (window && document.body) {
      onDocumentLoaded();
    } else {
      document.addEventListener("DOMContentLoaded", onDocumentLoaded);
    }
  }

  function encapsulateStyles(node) {
    setAttribute(node, "svelte-3216818801", "");
  }

  function add_css() {
    var style = createElement("style");
    style.id = 'svelte-3216818801-style';
    style.textContent = "[svelte-3216818801].ui-pnotify,[svelte-3216818801] .ui-pnotify{top:36px;right:36px;position:absolute;height:auto;z-index:2;display:none}body[svelte-3216818801] > .ui-pnotify,[svelte-3216818801] body > .ui-pnotify{position:fixed;z-index:100040}[svelte-3216818801].ui-pnotify.ui-pnotify-in,[svelte-3216818801] .ui-pnotify.ui-pnotify-in{display:block}[svelte-3216818801].ui-pnotify.ui-pnotify-move,[svelte-3216818801] .ui-pnotify.ui-pnotify-move{transition:left .5s ease, top .5s ease, right .5s ease, bottom .5s ease}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-slow,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-slow{transition:opacity .4s linear;opacity:0}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move{transition:opacity .4s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-normal,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-normal{transition:opacity .25s linear;opacity:0}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move{transition:opacity .25s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-fast,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-fast{transition:opacity .1s linear;opacity:0}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move{transition:opacity .1s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease}[svelte-3216818801].ui-pnotify.ui-pnotify-fade-in,[svelte-3216818801] .ui-pnotify.ui-pnotify-fade-in{opacity:1}[svelte-3216818801].ui-pnotify .ui-pnotify-shadow,[svelte-3216818801] .ui-pnotify .ui-pnotify-shadow{-webkit-box-shadow:0px 6px 28px 0px rgba(0,0,0,0.1);-moz-box-shadow:0px 6px 28px 0px rgba(0,0,0,0.1);box-shadow:0px 6px 28px 0px rgba(0,0,0,0.1)}[svelte-3216818801].ui-pnotify-container,[svelte-3216818801] .ui-pnotify-container{background-position:0 0;padding:.8em;height:100%;margin:0}[svelte-3216818801].ui-pnotify-container:after,[svelte-3216818801] .ui-pnotify-container:after{content:\" \";visibility:hidden;display:block;height:0;clear:both}[svelte-3216818801].ui-pnotify-container.ui-pnotify-sharp,[svelte-3216818801] .ui-pnotify-container.ui-pnotify-sharp{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}[svelte-3216818801].ui-pnotify-title,[svelte-3216818801] .ui-pnotify-title{display:block;margin-bottom:.4em;margin-top:0}[svelte-3216818801].ui-pnotify-text,[svelte-3216818801] .ui-pnotify-text{display:block}[svelte-3216818801].ui-pnotify-icon,[svelte-3216818801] .ui-pnotify-icon,[svelte-3216818801].ui-pnotify-icon span,[svelte-3216818801] .ui-pnotify-icon span{display:block;float:left;margin-right:.2em}[svelte-3216818801].ui-pnotify.stack-topleft,[svelte-3216818801] .ui-pnotify.stack-topleft,[svelte-3216818801].ui-pnotify.stack-bottomleft,[svelte-3216818801] .ui-pnotify.stack-bottomleft{left:25px;right:auto}[svelte-3216818801].ui-pnotify.stack-bottomright,[svelte-3216818801] .ui-pnotify.stack-bottomright,[svelte-3216818801].ui-pnotify.stack-bottomleft,[svelte-3216818801] .ui-pnotify.stack-bottomleft{bottom:25px;top:auto}[svelte-3216818801].ui-pnotify.stack-modal,[svelte-3216818801] .ui-pnotify.stack-modal{left:50%;right:auto;margin-left:-150px}[svelte-3216818801].ui-pnotify-modal-overlay,[svelte-3216818801] .ui-pnotify-modal-overlay{background-color:rgba(0, 0, 0, .4);top:0;left:0;position:absolute;height:100%;width:100%;z-index:1}body[svelte-3216818801] > .ui-pnotify-modal-overlay,[svelte-3216818801] body > .ui-pnotify-modal-overlay{position:fixed;z-index:100039}[svelte-3216818801].ui-pnotify-modal-overlay-hidden,[svelte-3216818801] .ui-pnotify-modal-overlay-hidden{display:none}";
    appendNode(style, document.head);
  }

  function create_main_fragment(state, component) {
    var div, div_class_value, div_style_value, div_1, div_1_class_value, text, h4, text_2, div_2;

    function mouseenter_handler(event) {
      component.mouseenter(event);
    }

    function mouseleave_handler(event) {
      component.mouseleave(event);
    }

    var if_block = state.icon !== false && create_if_block(state, component);

    var current_block_type = select_block_type(state);
    var if_block_1 = current_block_type(state, component);

    var current_block_type_1 = select_block_type_1(state);
    var if_block_2 = current_block_type_1(state, component);

    return {
      c: function create() {
        div = createElement("div");
        div_1 = createElement("div");
        if (if_block) if_block.c();
        text = createText("\n    ");
        h4 = createElement("h4");
        if_block_1.c();
        text_2 = createText("\n    ");
        div_2 = createElement("div");
        if_block_2.c();
        this.h();
      },

      h: function hydrate() {
        encapsulateStyles(div);
        div.className = div_class_value = "ui-pnotify " + state.addclass + " " + state._animatingClass + " " + state._moveClass + " " + (state.animation === 'fade' ? 'ui-pnotify-fade-' + state.animate_speed : '');
        div.style.cssText = div_style_value = "\n      " + (typeof state.width === 'string' ? 'width: ' + state.width + ';' : '') + "\n      " + (typeof state.min_height === 'string' ? 'min-height: ' + state.min_height + ';' : '') + "\n    ";
        setAttribute(div, "aria-live", "assertive");
        setAttribute(div, "aria-role", "alertdialog");
        addListener(div, "mouseenter", mouseenter_handler);
        addListener(div, "mouseleave", mouseleave_handler);
        div_1.className = div_1_class_value = "ui-pnotify-container " + state._styles.container + " " + state._styles[state.type] + " " + state.cornerclass + " " + (state.shadow ? 'ui-pnotify-shadow' : '');
        setAttribute(div_1, "role", "alert");
        h4.className = "ui-pnotify-title";
        setStyle(h4, "display", state.title === false ? 'none' : 'block');
        div_2.className = "ui-pnotify-text";
        setStyle(div_2, "display", state.text === false ? 'none' : 'block');
        setAttribute(div_2, "aria-role", "alert");
      },

      m: function mount(target, anchor) {
        insertNode(div, target, anchor);
        component.refs.elem = div;
        appendNode(div_1, div);
        component.refs.container = div_1;
        if (if_block) if_block.m(div_1, null);
        appendNode(text, div_1);
        appendNode(h4, div_1);
        component.refs.titleContainer = h4;
        if_block_1.m(h4, null);
        appendNode(text_2, div_1);
        appendNode(div_2, div_1);
        component.refs.textContainer = div_2;
        if_block_2.m(div_2, null);
      },

      p: function update(changed, state) {
        if ((changed.addclass || changed._animatingClass || changed._moveClass || changed.animation || changed.animate_speed) && div_class_value !== (div_class_value = "ui-pnotify " + state.addclass + " " + state._animatingClass + " " + state._moveClass + " " + (state.animation === 'fade' ? 'ui-pnotify-fade-' + state.animate_speed : ''))) {
          div.className = div_class_value;
        }

        if ((changed.width || changed.min_height) && div_style_value !== (div_style_value = "\n      " + (typeof state.width === 'string' ? 'width: ' + state.width + ';' : '') + "\n      " + (typeof state.min_height === 'string' ? 'min-height: ' + state.min_height + ';' : '') + "\n    ")) {
          div.style.cssText = div_style_value;
        }

        if ((changed._styles || changed.type || changed.cornerclass || changed.shadow) && div_1_class_value !== (div_1_class_value = "ui-pnotify-container " + state._styles.container + " " + state._styles[state.type] + " " + state.cornerclass + " " + (state.shadow ? 'ui-pnotify-shadow' : ''))) {
          div_1.className = div_1_class_value;
        }

        if (state.icon !== false) {
          if (if_block) {
            if_block.p(changed, state);
          } else {
            if_block = create_if_block(state, component);
            if_block.c();
            if_block.m(div_1, text);
          }
        } else if (if_block) {
          if_block.u();
          if_block.d();
          if_block = null;
        }

        if (changed.title) {
          setStyle(h4, "display", state.title === false ? 'none' : 'block');
        }

        if (current_block_type === (current_block_type = select_block_type(state)) && if_block_1) {
          if_block_1.p(changed, state);
        } else {
          if_block_1.u();
          if_block_1.d();
          if_block_1 = current_block_type(state, component);
          if_block_1.c();
          if_block_1.m(h4, null);
        }

        if (changed.text) {
          setStyle(div_2, "display", state.text === false ? 'none' : 'block');
        }

        if (current_block_type_1 === (current_block_type_1 = select_block_type_1(state)) && if_block_2) {
          if_block_2.p(changed, state);
        } else {
          if_block_2.u();
          if_block_2.d();
          if_block_2 = current_block_type_1(state, component);
          if_block_2.c();
          if_block_2.m(div_2, null);
        }
      },

      u: function unmount() {
        detachNode(div);
        if (if_block) if_block.u();
        if_block_1.u();
        if_block_2.u();
      },

      d: function destroy() {
        removeListener(div, "mouseenter", mouseenter_handler);
        removeListener(div, "mouseleave", mouseleave_handler);
        if (component.refs.elem === div) component.refs.elem = null;
        if (component.refs.container === div_1) component.refs.container = null;
        if (if_block) if_block.d();
        if (component.refs.titleContainer === h4) component.refs.titleContainer = null;
        if_block_1.d();
        if (component.refs.textContainer === div_2) component.refs.textContainer = null;
        if_block_2.d();
      }
    };
  }

  // (26:4) {{#if icon !== false}}
  function create_if_block(state, component) {
    var div, span, span_class_value;

    return {
      c: function create() {
        div = createElement("div");
        span = createElement("span");
        this.h();
      },

      h: function hydrate() {
        div.className = "ui-pnotify-icon";
        span.className = span_class_value = state.icon === true ? state._styles[state.type + '_icon'] : state.icon;
      },

      m: function mount(target, anchor) {
        insertNode(div, target, anchor);
        appendNode(span, div);
      },

      p: function update(changed, state) {
        if ((changed.icon || changed._styles || changed.type) && span_class_value !== (span_class_value = state.icon === true ? state._styles[state.type + '_icon'] : state.icon)) {
          span.className = span_class_value;
        }
      },

      u: function unmount() {
        detachNode(div);
      },

      d: noop
    };
  }

  // (32:6) {{#if title_escape}}
  function create_if_block_1(state, component) {
    var text;

    return {
      c: function create() {
        text = createText(state.title);
      },

      m: function mount(target, anchor) {
        insertNode(text, target, anchor);
      },

      p: function update(changed, state) {
        if (changed.title) {
          text.data = state.title;
        }
      },

      u: function unmount() {
        detachNode(text);
      },

      d: noop
    };
  }

  // (34:6) {{else}}
  function create_if_block_2(state, component) {
    var raw_before, raw_after;

    return {
      c: function create() {
        raw_before = createElement('noscript');
        raw_after = createElement('noscript');
      },

      m: function mount(target, anchor) {
        insertNode(raw_before, target, anchor);
        raw_before.insertAdjacentHTML("afterend", state.title);
        insertNode(raw_after, target, anchor);
      },

      p: function update(changed, state) {
        if (changed.title) {
          detachBetween(raw_before, raw_after);
          raw_before.insertAdjacentHTML("afterend", state.title);
        }
      },

      u: function unmount() {
        detachBetween(raw_before, raw_after);

        detachNode(raw_before);
        detachNode(raw_after);
      },

      d: noop
    };
  }

  // (39:6) {{#if text_escape}}
  function create_if_block_3(state, component) {
    var text;

    return {
      c: function create() {
        text = createText(state.text);
      },

      m: function mount(target, anchor) {
        insertNode(text, target, anchor);
      },

      p: function update(changed, state) {
        if (changed.text) {
          text.data = state.text;
        }
      },

      u: function unmount() {
        detachNode(text);
      },

      d: noop
    };
  }

  // (41:6) {{else}}
  function create_if_block_4(state, component) {
    var raw_before, raw_after;

    return {
      c: function create() {
        raw_before = createElement('noscript');
        raw_after = createElement('noscript');
      },

      m: function mount(target, anchor) {
        insertNode(raw_before, target, anchor);
        raw_before.insertAdjacentHTML("afterend", state._text_processed);
        insertNode(raw_after, target, anchor);
      },

      p: function update(changed, state) {
        if (changed._text_processed) {
          detachBetween(raw_before, raw_after);
          raw_before.insertAdjacentHTML("afterend", state._text_processed);
        }
      },

      u: function unmount() {
        detachBetween(raw_before, raw_after);

        detachNode(raw_before);
        detachNode(raw_after);
      },

      d: noop
    };
  }

  function select_block_type(state) {
    if (state.title_escape) return create_if_block_1;
    return create_if_block_2;
  }

  function select_block_type_1(state) {
    if (state.text_escape) return create_if_block_3;
    return create_if_block_4;
  }

  function PNotify_1(options) {
    init(this, options);
    this.refs = {};
    this._state = assign(data(), options.data);
    this._recompute({ text: 1, insert_brs: 1, styling: 1 }, this._state);

    if (!document.getElementById("svelte-3216818801-style")) add_css();

    var _oncreate = oncreate.bind(this);

    if (!options._root) {
      this._oncreate = [_oncreate];
    } else {
      this._root._oncreate.push(_oncreate);
    }

    this._fragment = create_main_fragment(this._state, this);

    if (options.target) {
      this._fragment.c();
      this._fragment.m(options.target, options.anchor || null);

      callAll(this._oncreate);
    }
  }

  assign(PNotify_1.prototype, methods, {
    destroy: destroy,
    get: get,
    fire: fire,
    observe: observe,
    on: on,
    set: set,
    teardown: destroy,
    _set: _set,
    _mount: _mount,
    _unmount: _unmount
  });

  PNotify_1.prototype._recompute = function _recompute(changed, state) {
    if (changed.text || changed.insert_brs) {
      if (differs(state._text_processed, state._text_processed = _text_processed(state.text, state.insert_brs))) changed._text_processed = true;
    }

    if (changed.styling) {
      if (differs(state._styles, state._styles = _styles(state.styling))) changed._styles = true;
    }
  };

  setup(PNotify_1);

  function setAttribute(node, attribute, value) {
    node.setAttribute(attribute, value);
  }

  function createElement(name) {
    return document.createElement(name);
  }

  function appendNode(node, target) {
    target.appendChild(node);
  }

  function createText(data) {
    return document.createTextNode(data);
  }

  function addListener(node, event, handler) {
    node.addEventListener(event, handler, false);
  }

  function setStyle(node, key, value) {
    node.style.setProperty(key, value);
  }

  function insertNode(node, target, anchor) {
    target.insertBefore(node, anchor);
  }

  function detachNode(node) {
    node.parentNode.removeChild(node);
  }

  function removeListener(node, event, handler) {
    node.removeEventListener(event, handler, false);
  }

  function noop() {}

  function detachBetween(before, after) {
    while (before.nextSibling && before.nextSibling !== after) {
      before.parentNode.removeChild(before.nextSibling);
    }
  }

  function init(component, options) {
    component.options = options;

    component._observers = { pre: blankObject(), post: blankObject() };
    component._handlers = blankObject();
    component._root = options._root || component;
    component._yield = options._yield;
    component._bind = options._bind;
  }

  function assign(target) {
    var k,
        source,
        i = 1,
        len = arguments.length;
    for (; i < len; i++) {
      source = arguments[i];
      for (k in source) {
        target[k] = source[k];
      }
    }

    return target;
  }

  function callAll(fns) {
    while (fns && fns.length) {
      fns.pop()();
    }
  }

  function destroy(detach) {
    this.destroy = noop;
    this.fire('destroy');
    this.set = this.get = noop;

    if (detach !== false) this._fragment.u();
    this._fragment.d();
    this._fragment = this._state = null;
  }

  function get(key) {
    return key ? this._state[key] : this._state;
  }

  function fire(eventName, data) {
    var handlers = eventName in this._handlers && this._handlers[eventName].slice();
    if (!handlers) return;

    for (var i = 0; i < handlers.length; i += 1) {
      handlers[i].call(this, data);
    }
  }

  function observe(key, callback, options) {
    var group = options && options.defer ? this._observers.post : this._observers.pre;

    (group[key] || (group[key] = [])).push(callback);

    if (!options || options.init !== false) {
      callback.__calling = true;
      callback.call(this, this._state[key]);
      callback.__calling = false;
    }

    return {
      cancel: function cancel() {
        var index = group[key].indexOf(callback);
        if (~index) group[key].splice(index, 1);
      }
    };
  }

  function on(eventName, handler) {
    if (eventName === 'teardown') return this.on('destroy', handler);

    var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
    handlers.push(handler);

    return {
      cancel: function cancel() {
        var index = handlers.indexOf(handler);
        if (~index) handlers.splice(index, 1);
      }
    };
  }

  function set(newState) {
    this._set(assign({}, newState));
    if (this._root._lock) return;
    this._root._lock = true;
    callAll(this._root._beforecreate);
    callAll(this._root._oncreate);
    callAll(this._root._aftercreate);
    this._root._lock = false;
  }

  function _set(newState) {
    var oldState = this._state,
        changed = {},
        dirty = false;

    for (var key in newState) {
      if (differs(newState[key], oldState[key])) changed[key] = dirty = true;
    }
    if (!dirty) return;

    this._state = assign({}, oldState, newState);
    this._recompute(changed, this._state);
    if (this._bind) this._bind(changed, this._state);
    dispatchObservers(this, this._observers.pre, changed, this._state, oldState);
    this._fragment.p(changed, this._state);
    dispatchObservers(this, this._observers.post, changed, this._state, oldState);
  }

  function _mount(target, anchor) {
    this._fragment.m(target, anchor);
  }

  function _unmount() {
    this._fragment.u();
  }

  function differs(a, b) {
    return a !== b || a && (typeof a === "undefined" ? "undefined" : _typeof(a)) === 'object' || typeof a === 'function';
  }

  function blankObject() {
    return Object.create(null);
  }

  function dispatchObservers(component, group, changed, newState, oldState) {
    for (var key in group) {
      if (!changed[key]) continue;

      var newValue = newState[key];
      var oldValue = oldState[key];

      var callbacks = group[key];
      if (!callbacks) continue;

      for (var i = 0; i < callbacks.length; i += 1) {
        var callback = callbacks[i];
        if (callback.__calling) continue;

        callback.__calling = true;
        callback.call(component, newValue, oldValue);
        callback.__calling = false;
      }
    }
  }
  return PNotify_1;
}();
//# sourceMappingURL=PNotify.js.map