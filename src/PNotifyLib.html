<div ref:elem
    class="ui-pnotify {{addclass}} {{animation === 'fade' ? 'ui-pnotify-fade-'+animate_speed}}"
    style="
      display: none;
      {{#if typeof width === 'string'}}
        width: {{width}};
      {{/if}}
      {{#if typeof min_height === 'string'}}
        min-height: {{min_height}};
      {{/if}}
    "
    aria-live="assertive"
    aria-role="alertdialog"
    on:mouseenter="mouseenter(event)"
    on:mouseleave="mouseleave(event)">
  <div ref:container
      class="ui-pnotify-container {{_styles.container}} {{_styles[type]}} {{cornerclass}} {{#if shadow}}ui-pnotify-shadow{{/if}}"
      role="alert">
    {{#if icon !== false}}
      <div class="ui-pnotify-icon">
        <span class="{{icon === true ? _styles[type+'_icon'] : icon}}"></span>
      </div>
    {{/if}}
    <h4 ref:titleContainer class="ui-pnotify-title" style="display: {{title === false ? 'none' : 'block'}}">
      {{#if title_escape}}
        {{title}}
      {{else}}
        {{{title}}}
      {{/if}}
    </h4>
    <div ref:textContainer class="ui-pnotify-text" style="display: {{text === false ? 'none' : 'block'}}" aria-role="alert">
      {{#if text_escape}}
        {{text}}
      {{else}}
        {{{text_processed)}}}
      {{/if}}
    </div>
  </div>
</div>

<script>
  let default_stack = {
    dir1: "down",
    dir2: "left",
    push: "bottom",
    spacing1: 36,
    spacing2: 36,
    context: window && window.document.body,
    modal: false
  };
  let posTimer; // Position all timer.
  // Set global variables.
  let do_when_ready = function(){
    PNotify.prototype.options.stack.context = window.document.body;
    jwindow = $(root);
    // Reposition the notices when the window resizes.
    jwindow.bind('resize', function(){
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = setTimeout(function(){
        PNotify.positionAll(true);
      }, 10);
    });
  };
  let createStackOverlay = function(stack) {
    var overlay = $("<div />", {"class": "ui-pnotify-modal-overlay"});
    overlay.prependTo(stack.context);
    if (stack.overlay_close) {
      // Close the notices on overlay click.
      overlay.click(function(){
        PNotify.removeStack(stack);
      });
    }
    return overlay;
  };

  export default {
    setup: (PNotify) {
      PNotify.VERSION = "4.0.0";
      PNotify.notices = [];
      PNotify.modules = {};

      PNotify.removeAll = () => {};
      PNotify.removeStack = () => {};
      PNotify.positionAll = () => {};
      PNotify.styling = {
        brighttheme: {
          // Bright Theme doesn't require any UI libraries.
          container: "brighttheme",
          notice: "brighttheme-notice",
          notice_icon: "brighttheme-icon-notice",
          info: "brighttheme-info",
          info_icon: "brighttheme-icon-info",
          success: "brighttheme-success",
          success_icon: "brighttheme-icon-success",
          error: "brighttheme-error",
          error_icon: "brighttheme-icon-error"
        },
        bootstrap3: {
          container: "alert",
          notice: "alert-warning",
          notice_icon: "glyphicon glyphicon-exclamation-sign",
          info: "alert-info",
          info_icon: "glyphicon glyphicon-info-sign",
          success: "alert-success",
          success_icon: "glyphicon glyphicon-ok-sign",
          error: "alert-danger",
          error_icon: "glyphicon glyphicon-warning-sign"
        }
      };
      /*
       * uses icons from http://fontawesome.io/
       * version 4.0.3
       */
      PNotify.styling.fontawesome = Object.assign({}, PNotify.styling.bootstrap3);
      Object.assign(PNotify.styling.fontawesome, {
        notice_icon: "fa fa-exclamation-circle",
        info_icon: "fa fa-info",
        success_icon: "fa fa-check",
        error_icon: "fa fa-warning"
      });

      if (window && window.document.body) {
        do_when_ready();
      } else {
        $(do_when_ready);
      }
    },

    oncreate () {
      this.set({
        "_state": "initializing", // The state can be "initializing", "opening", "open", "closing", and "closed".
        "_timer": null, // Auto close timer.
        "_animTimer": null, // Animation timer.
        "_styles": null,
        "_elem": null,
        "_container": null,
        "_title_container": null,
        "_text_container": null,
        "_animating": false, // Stores what is currently being animated (in or out).
        "_timerHide": false, // Stores whether the notice was hidden by a timer.
      });

      // We don't want our module objects all referencing the prototype.
      this.set({"_modules": Object.assign({}, PNotify.prototype.modules)});

      // Get our styling object.
      if (typeof this.get("styling") === "object") {
        this.set({"_styles": this.get("styling")});
      } else {
        this.set({"_styles": PNotify.styling[this.get("styling")]});
      }

      // Add the notice to the notice array.
      if (this.get("stack").push === "top") {
        PNotify.notices.splice(0, 0, this);
        // Now position all the notices if they are to push to the top.
        this.queuePosition(false, 1);
      } else {
        PNotify.notices.push(this);
      }

      // Mark the stack so it won't animate the new notice.
      this.get("stack").animation = false;

      // Run the modules.
      this.runModules('init');

      // We're now initialized, but haven't been opened yet.
      this.set({"_state": "closed"});

      // Display the notice.
      if (this.get("auto_display")) {
        this.open();
      }
    },

    data () {
      return {
        // The notice's title.
        title: false,
        // Whether to escape the content of the title. (Not allow HTML.)
        title_escape: false,
        // The notice's text.
        text: false,
        // Whether to escape the content of the text. (Not allow HTML.)
        text_escape: false,
        // What styling classes to use. (Can be either "brighttheme", "bootstrap3", or "fontawesome".)
        styling: "brighttheme",
        // Additional classes to be added to the notice. (For custom styling.)
        addclass: "",
        // Class to be added to the notice for corner styling.
        cornerclass: "",
        // Display the notice when it is created.
        auto_display: true,
        // Width of the notice.
        width: "300px",
        // Minimum height of the notice. It will expand to fit content.
        min_height: "16px",
        // Type of the notice. "notice", "info", "success", or "error".
        type: "notice",
        // Set icon to true to use the default icon for the selected
        // style/type, false for no icon, or a string for your own icon class.
        icon: true,
        // The animation to use when displaying and hiding the notice. "none"
        // and "fade" are supported through CSS. Others are supported
        // through the Animate module and Animate.css.
        animation: "fade",
        // Speed at which the notice animates in and out. "slow", "normal",
        // or "fast". Respectively, 400ms, 250ms, 100ms.
        animate_speed: "normal",
        // Display a drop shadow.
        shadow: true,
        // After a delay, remove the notice.
        hide: true,
        // Delay in milliseconds before the notice is removed.
        delay: 8000,
        // Reset the hide timer if the mouse moves over the notice.
        mouse_reset: true,
        // Remove the notice's elements from the DOM after it is removed.
        remove: true,
        // Change new lines to br tags.
        insert_brs: true,
        // Whether to remove the notice from the global array when it is closed.
        destroy: true,
        // The stack on which the notices will be placed. Also controls the
        // direction the notices stack.
        stack: default_stack
      }
    },

    computed: {
      text_processed: (text, insert_brs) => insert_brs ?  String(text).replace(/\n/g, '<br />') : text
    },

    methods: {
      update(options) {
        // Save old options.
        const oldHide = this.get("hide");

        // Run the modules.
        this.runModules('update', options);

        this.set(options);

        // Update the timed hiding.
        if (!this.get("hide")) {
          this.cancelRemove();
        } else if (!oldHide) {
          this.queueRemove();
        }
        this.queuePosition(true);

        return this;
      },

      mouseenter(e) {
        // Stop animation, reset the removal timer when the user mouses over.
        if (this.get("mouse_reset") && this.get("_animating") === "out") {
          if (!this.get("_timerHide")) {
            return;
          }
          this.cancelRemove();
        }
        // Stop the close timer.
        if (this.get("hide") && this.get("mouse_reset")) {
          this.cancelRemove();
        }
      },

      mouseleave(e) {
        // Start the close timer.
        if (this.get("hide") && this.get("mouse_reset") && this.get("_animating") !== "out") {
          this.queueRemove();
        }
        PNotify.positionAll();
      },

      // Display the notice.
      open: function(){
        this.set({"_state": "opening"});
        // Run the modules.
        this.runModules('beforeOpen');

        let stack = this.get("stack");
        // If the notice is not in the DOM, append it.
        if (!this.refs.elem.parentNode) {
          if (stack.context) {
            stack.context.appendChild(this.refs.elem);
          } else if (document.body) {
            document.body.appendChild(this.refs.elem);
          } else {
            throw new Error("No context to open this notice in.");
          }
        }
        // Try to put it in the right position.
        if (stack.push !== "top") {
          this.position(true);
        }
        this.animateIn(() => {
          this.queuePosition(true);

          // Now set it to hide.
          if (this.get("hide")) {
            this.queueRemove();
          }

          this.set({"_state": "open"});

          // Run the modules.
          this.runModules('afterOpen');
        });

        return this;
      },

      // Remove the notice.
      remove: function(timer_hide) {
        this.set({"_state": "closing", "_timerHide": !!timer_hide}); // Make sure it's a boolean.
        // Run the modules.
        this.runModules('beforeClose');

        if (this.get("_timer") && clearTimeout) {
          clearTimeout(this.get("_timer"));
          this.set({"_timer": null});
        }
        this.animateOut(() => {
          this.set({"_state": "closed"});
          // Run the modules.
          this.runModules('afterClose');
          this.queuePosition(true);
          // If we're supposed to remove the notice from the DOM, do it.
          if (this.get("remove")) {
            this.refs.elem.parentNode.removeChild(this.refs.elem);
          }
          // Run the modules.
          this.runModules('beforeDestroy');
          // Remove object from PNotify.notices to prevent memory leak (issue #49)
          // unless destroy is off
          if (this.get("destroy")) {
            if (PNotify.notices !== null) {
              const idx = PNotify.notices.indexOf(this);
              if (idx !== -1) {
                PNotify.notices.splice(idx, 1);
              }
            }
          }
          // Run the modules.
          this.runModules('afterDestroy');
        });

        return this;
      },
    }
  };
</script>

<style>
  /* -- Notice */
  .ui-pnotify {
    top: 36px;
    right: 36px;
    position: absolute;
    height: auto;
    z-index: 2;
  }
  body > .ui-pnotify {
    /* Notices in the body context should be fixed to the viewport. */
    position: fixed;
    /* Ensures notices are above everything */
    z-index: 100040;
  }
  .ui-pnotify-modal-overlay {
    background-color: rgba(0, 0, 0, .4);
    top: 0;
    left: 0;
    position: absolute;
    height: 100%;
    width: 100%;
    z-index: 1;
  }
  body > .ui-pnotify-modal-overlay {
    position: fixed;
    z-index: 100039;
  }
  .ui-pnotify.ui-pnotify-in {
    display: block !important;
  }
  .ui-pnotify.ui-pnotify-move {
    transition: left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  .ui-pnotify.ui-pnotify-fade-slow {
    transition: opacity .4s linear;
    opacity: 0;
  }
  .ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move {
    transition: opacity .4s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  .ui-pnotify.ui-pnotify-fade-normal {
    transition: opacity .25s linear;
    opacity: 0;
  }
  .ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move {
    transition: opacity .25s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  .ui-pnotify.ui-pnotify-fade-fast {
    transition: opacity .1s linear;
    opacity: 0;
  }
  .ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move {
    transition: opacity .1s linear, left .5s ease, top .5s ease, right .5s ease, bottom .5s ease;
  }
  .ui-pnotify.ui-pnotify-fade-in {
    opacity: 1;
  }
  .ui-pnotify .ui-pnotify-shadow {
    -webkit-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    -moz-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
  }
  .ui-pnotify-container {
    background-position: 0 0;
    padding: .8em;
    height: 100%;
    margin: 0;
  }
  .ui-pnotify-container:after {
    content: " "; /* Older browser do not support empty content */
    visibility: hidden;
    display: block;
    height: 0;
    clear: both;
  }
  .ui-pnotify-container.ui-pnotify-sharp {
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
  }
  .ui-pnotify-title {
    display: block;
    margin-bottom: .4em;
    margin-top: 0;
  }
  .ui-pnotify-text {
    display: block;
  }
  .ui-pnotify-icon, .ui-pnotify-icon span {
    display: block;
    float: left;
    margin-right: .2em;
  }
  /* Alternate stack initial positioning. */
  .ui-pnotify.stack-topleft, .ui-pnotify.stack-bottomleft {
    left: 25px;
    right: auto;
  }
  .ui-pnotify.stack-bottomright, .ui-pnotify.stack-bottomleft {
    bottom: 25px;
    top: auto;
  }
  .ui-pnotify.stack-modal {
    left: 50%;
    right: auto;
    margin-left: -150px;
  }
</style>
