<!--
 ====== PNotify ======

 http://sciactive.com/pnotify/

 Copyright 2009-2020 Hunter Perrin
 Copyright 2015 Google, Inc.

 Licensed under Apache License, Version 2.0.
  http://www.apache.org/licenses/LICENSE-2.0
-->

<svelte:options accessors={true} />

<script context="module">
  import Stack from './Stack.js';

  let posTimer;

  // These actions need to be done once the DOM is ready.
  function onDocumentLoaded () {
    defaultStack.context = document.body;
    // Reposition the notices when the window resizes.
    window.addEventListener('resize', () => {
      // This timer is used for queueing the position event so it doesn't run
      // repeatedly.
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = setTimeout(() => {
        var event = new Event('pnotify:position');
        document.body.dispatchEvent(event);
        posTimer = null;
      }, 10);
    });
  }

  export const defaultStack = new Stack({
    dir1: 'down',
    dir2: 'left',
    firstpos1: 25,
    firstpos2: 25,
    spacing1: 36,
    spacing2: 36,
    push: 'bottom'
  });

  export const defaults = {
    // Type of the notice. 'notice', 'info', 'success', or 'error'.
    type: 'notice',
    // The notice's title. Can be a string, an element, or `false` for no title.
    title: false,
    // Whether to trust the title or escape its contents. (Not allow HTML.)
    titleTrusted: false,
    // The notice's text. Can be a string, an element, or `false` for no text.
    text: false,
    // Whether to trust the text or escape its contents. (Not allow HTML.)
    textTrusted: false,
    // What styling classes to use. (Can be 'brighttheme', 'material',
    // 'bootstrap3', 'bootstrap4', or a styling object.)
    styling: 'brighttheme',
    // What icons to use (Can be 'brighttheme', 'material', 'bootstrap3',
    // 'fontawesome4', 'fontawesome5', or an icon object.)
    icons: 'brighttheme',
    // Light or dark version of the theme, if supported by the styling. This
    // overrides the CSS media query when a preference is given. (Can be
    // 'no-preference', 'light', or 'dark'.)
    mode: 'no-preference',
    // Additional classes to be added to the notice. (For custom styling.)
    addClass: '',
    // Class to be added to the notice for corner styling.
    cornerClass: '',
    // Display the notice immediately when it is created.
    autoOpen: true,
    // Width of the notice.
    width: '360px',
    // Minimum height of the notice. It will expand to fit content.
    minHeight: '16px',
    // Set icon to true to use the default icon for the selected
    // style/type, false for no icon, or a string for your own icon class.
    icon: true,
    // The animation to use when displaying and hiding the notice. 'none'
    // and 'fade' are supported through CSS. Others are supported
    // through the Animate module and Animate.css.
    animation: 'fade',
    // Speed at which the notice animates in and out. 'slow', 'normal',
    // or 'fast'. Respectively, 400ms, 250ms, 100ms.
    animateSpeed: 'normal',
    // Display a drop shadow.
    shadow: true,
    // After a delay, remove the notice.
    hide: true,
    // Delay in milliseconds before the notice is removed.
    delay: 8000,
    // Reset the hide timer if the mouse moves over the notice.
    mouseReset: true,
    // Remove the notice's elements from the DOM after it is removed.
    remove: true,
    // Whether to remove the notice from the stack array (and therefore,
    // history) when it is closed.
    destroy: true,
    // The stack on which the notices will be placed. Also controls the
    // direction the notices stack.
    stack: defaultStack,
    // This is where options for modules should be defined.
    modules: {}
  };

  // This object holds all the PNotify modules. They are used to provide
  // additional functionality.
  const moduleRegistry = {};
  export { moduleRegistry as modules };

  // Modules can add themselves to these to be rendered in the template.
  export const modulesPrependContainer = [];
  export const modulesAppendContainer = [];
  export const modulesPrependContent = [];
  export const modulesAppendContent = [];

  const styleRegistry = {
    bootstrap3: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    },
    bootstrap4: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    }
  };
  export { styleRegistry as styles };

  // icons are separate from the style, since bs4 doesn't come with any
  const iconRegistry = {
    bootstrap3: {
      notice: 'glyphicon glyphicon-exclamation-sign',
      info: 'glyphicon glyphicon-info-sign',
      success: 'glyphicon glyphicon-ok-sign',
      error: 'glyphicon glyphicon-warning-sign'
    },
    // User must have Font Awesome v4.0+
    fontawesome4: {
      notice: 'fa fa-exclamation-circle',
      info: 'fa fa-info-circle',
      success: 'fa fa-check-circle',
      error: 'fa fa-exclamation-triangle'
    },
    // User must have Font Awesome v5.0+
    fontawesome5: {
      notice: 'fas fa-exclamation-circle',
      info: 'fas fa-info-circle',
      success: 'fas fa-check-circle',
      error: 'fas fa-exclamation-triangle'
    }
  };
  export { iconRegistry as icons };

  // Run the deferred actions once the DOM is ready.
  if (window && document.body) {
    onDocumentLoaded();
  } else {
    document.addEventListener('DOMContentLoaded', onDocumentLoaded);
  }
</script>

<div bind:this={refs.elem}
    class="
      ui-pnotify
      {icon !== false ? 'ui-pnotify-with-icon' : ''}
      {getStyle('element')}
      ui-pnotify-mode-{mode}
      {addClass}
      {_animatingClass}
      {_moveClass}
      {animation === 'fade' ? 'ui-pnotify-fade-'+animateSpeed : ''}
      {stack && (stack.modal === true || stack._overlayInserted) ? 'ui-pnotify-modal' : ''}
      {_masking ? 'ui-pnotify-masking' : ''}
      {_moduleClasses.elem.join(' ')}
    "
    aria-live="assertive"
    role="alertdialog"
    on:mouseenter={handleInteraction}
    on:mouseleave={handleLeaveInteraction}
    on:focusin={handleInteraction}
    on:focusout={handleLeaveInteraction}
    ui-pnotify
    on:mouseover
    on:mouseout
    on:mouseenter
    on:mouseleave
    on:mousemove
    on:mousedown
    on:mouseup
    on:click
    on:dblclick
    on:focus
    on:blur
    on:focusin
    on:focusout
    on:touchstart
    on:touchmove
    on:touchend
    on:touchcancel
    on:animationend
    on:transitionend>
  <div bind:this={refs.container}
      class="
        ui-pnotify-container
        {getStyle('container')}
        {getStyle(type)}
        {cornerClass}
        {shadow ? 'ui-pnotify-shadow' : ''}
        {_moduleClasses.container.join(' ')}
      "
      style="{_widthStyle} {_minHeightStyle}"
      role="alert">
    {#if self}
      {#each modulesPrependContainer as module (module.key)}
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
    {#if icon !== false}
      <div bind:this={refs.iconContainer} class="ui-pnotify-icon {getStyle('icon')}">
        <span class={icon === true ? getIcon(type) : icon}></span>
      </div>
    {/if}
    <div bind:this={refs.content} class="ui-pnotify-content {getStyle('content')}">
      {#if self}
        {#each modulesPrependContent as module (module.key)}
          <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
        {/each}
      {/if}
      {#if title !== false}
        <div bind:this={refs.titleContainer} class="ui-pnotify-title {getStyle('title')}">
          {#if !_titleElement}
            {#if titleTrusted}
              {@html title}
            {:else}
              <span class="ui-pnotify-pre-line">{title}</span>
            {/if}
          {/if}
        </div>
      {/if}
      {#if text !== false}
        <div bind:this={refs.textContainer} class="ui-pnotify-text {getStyle('text')}" role="alert">
          {#if !_textElement}
            {#if textTrusted}
              {@html text}
            {:else}
            <span class="ui-pnotify-pre-line">{text}</span>
            {/if}
          {/if}
        </div>
      {/if}
      {#if self}
        {#each modulesAppendContent as module (module.key)}
          <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
        {/each}
      {/if}
    </div>
    {#if self}
      {#each modulesAppendContainer as module (module.key)}
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
  </div>
</div>

<script>
  import { onMount, beforeUpdate, tick, createEventDispatcher } from 'svelte';

  let self;
  const dispatch = createEventDispatcher();

  export let type = defaults.type;
  export let title = defaults.title;
  export let titleTrusted = defaults.titleTrusted;
  export let text = defaults.text;
  export let textTrusted = defaults.textTrusted;
  export let styling = defaults.styling;
  export let icons = defaults.icons;
  export let mode = defaults.mode;
  export let addClass = defaults.addClass;
  export let cornerClass = defaults.cornerClass;
  export let autoOpen = defaults.autoOpen;
  export let width = defaults.width;
  export let minHeight = defaults.minHeight;
  export let icon = defaults.icon;
  export let animation = defaults.animation;
  export let animateSpeed = defaults.animateSpeed;
  export let shadow = defaults.shadow;
  export let hide = defaults.hide;
  export let delay = defaults.delay;
  export let mouseReset = defaults.mouseReset;
  export let remove = defaults.remove;
  export let destroy = defaults.destroy;
  export let stack = defaults.stack;
  export let modules = Object.assign({}, defaults.modules);

  export const refs = {
    elem: null,
    container: null,
    content: null,
    iconContainer: null,
    titleContainer: null,
    textContainer: null
  };

  // The state can be 'initializing', 'waiting', 'opening', 'open', 'closing',
  // or 'closed'.
  let _state = 'initializing';
  // Auto close timer.
  let _timer = null;
  // Animation timer.
  let _animTimer = null;
  // Stores what is currently being animated (in or out).
  let _animating = false;
  // Stores the class that adds entry/exit animation effects.
  let _animatingClass = '';
  // Stores the class that adds movement animation effects.
  let _moveClass = '';
  // Stores whether the notice was hidden by a timer.
  let _timerHide = false;
  // Stores the accessors of the modules.
  let _moduleAccessors = {};
  // Holds classes that modules add for the notice element or container element.
  let _moduleClasses = {
    elem: [],
    container: []
  };
  // Modules that change how the notice displays (causing the notice element to
  // not appear) can set this to true to make PNotify assume the notice has
  // opened.
  let _moduleIsNoticeOpen = false;
  // The masking control for the second notice in a modalish stack when the
  // first notice is hovered.
  let _masking = false;

  // These hold the instances to the Svelte-loaded modules.
  // const _modulesPrependContainerInstances = [];
  // const _modulesAppendContainerInstances = [];

  // This keeps the beforeUpdate handler from going into a loop when we're
  // taming Font Awesome's magic.
  let _updatingIcon = false;
  // Save the old value of hide and icon, so we can do our magic.
  let _oldHide = hide;
  let _oldIcon = icon;

  // Grab styles from the styling object or use the styles provided.
  $: _styles = typeof styling === 'object' ? styling : styleRegistry[styling];
  // Grab the icons from the icons object or use provided icons
  $: _icons = typeof icons === 'object' ? icons : iconRegistry[icons];
  $: _widthStyle = typeof width === 'string' ? 'width: ' + width + ';' : '';
  $: _minHeightStyle = typeof minHeight === 'string' ? 'min-height: ' + minHeight + ';' : '';
  $: _titleElement = title instanceof HTMLElement;
  $: _textElement = text instanceof HTMLElement;

  export const getState = () => _state;
  export const getStyle = name => (_styles && name in _styles) ? _styles[name] : styling + '-' + name;
  export const getIcon = name => (_icons && name in _icons) ? _icons[name] : icons + '-icon-' + name;

  beforeUpdate(async () => {
    if (_updatingIcon) {
      return;
    }

    runModules('update');

    // Update the timed hiding.
    if (_state !== 'closed' && _state !== 'waiting' && hide !== _oldHide) {
      if (!hide) {
        cancelClose();
      } else if (!_oldHide) {
        queueClose();
      }
    }

    // Queue a position
    if (_state !== 'closed' && stack) {
      stack.queuePosition();
    }

    // Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
    // In order to make it play nice with Svelte, we have to clear the element
    // and make it again.
    if (
      icon !== _oldIcon &&
      (
        (icon === true && icons === 'fontawesome5') ||
        (typeof icon === 'string' && icon.match(/(^| )fa[srlb]($| )/))
      )
    ) {
      const newIcon = icon;
      icon = false;
      _updatingIcon = true;
      await tick();
      icon = newIcon;
      _updatingIcon = false;
    }

    // Save old options.
    _oldHide = hide;
    _oldIcon = icon;
  });

  $: if (_titleElement && refs.titleContainer) {
    refs.titleContainer.appendChild(title);
  }

  $: if (_textElement && refs.textContainer) {
    refs.textContainer.appendChild(text);
  }

  function handleInteraction (e) {
    // Stop animation, reset the removal timer when the user interacts.
    if (mouseReset && _state === 'closing') {
      if (!_timerHide) {
        return;
      }
      cancelClose();
    }
    // Stop the close timer.
    if (hide && mouseReset) {
      cancelClose();
    }
  }

  function handleLeaveInteraction (e) {
    // Start the close timer.
    if (hide && mouseReset && _animating !== 'out') {
      queueClose();
    }
    if (stack) {
      stack.position();
    }
  }

  export async function init (notice) {
    // Init is passed the instance, since Svelte does not give access to it.
    self = notice;

    if (stack) {
      // Add the notice to the notice array.
      stack._addNotice(self);
    }

    // Wait for self to propagate to modules.
    await tick();

    runModules('init');

    // We're now initialized, but haven't been opened yet.
    _state = 'closed';

    // Display the notice.
    if (autoOpen) {
      open();
    }
  }

  // This runs an event on all the modules.
  function runModules (event) {
    if (event === 'init') {
      // Initializing a module should only be done if it has an init
      // function, which means it's not rendered in the template.
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        initModule(key, _moduleAccessors[key]);
      }
      for (let key in moduleRegistry) {
        if (!moduleRegistry.hasOwnProperty(key)) {
          continue;
        }
        if ('factory' in moduleRegistry[key]) {
          const moduleOptions = Object.assign({
            _notice: self
          }, modules[key]);
          _moduleAccessors[key] = moduleRegistry[key].factory(self, moduleOptions);
          initModule(key, _moduleAccessors[key]);
        }
      }
    } else {
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        if (event === 'update') {
          if ('$set' in _moduleAccessors[key]) {
            const moduleOptions = Object.assign({
              _notice: self
            }, modules[key]);
            _moduleAccessors[key].$set(moduleOptions);
          }
        } else {
          if (event in _moduleAccessors[key]) {
            _moduleAccessors[key][event]();
          }
        }
      }
    }
  }

  function saveAccessor (key, accessor) {
    _moduleAccessors[key] = accessor;
  }

  // This passes module options to a module.
  function initModule (key, accessor) {
    if (!modules.hasOwnProperty(key)) {
      modules[key] = {};
    }
    if ('$set' in accessor) {
      const moduleOptions = Object.assign({
        _notice: self
      }, modules[key]);
      accessor.$set(moduleOptions);
    }
    if ('init' in accessor) {
      accessor.init();
    }
  }

  // Display the notice.
  export let open = () => {
    if (_state === 'opening') {
      return;
    }
    if (_state === 'open') {
      if (hide) {
        queueClose();
      }
      return;
    }

    // Check the max in stack.
    if (_state !== 'waiting' && stack && !(stack.modal === 'ish' && stack._overlayOpen)) {
      if (stack.maxOpen !== Infinity) {
        if (stack._openNotices >= stack.maxOpen) {
          if (stack.maxStrategy === 'close') {
            stack.forEach(notice => {
              if (
                ['opening', 'open'].indexOf(notice.getState()) !== -1
              ) {
                // Close oldest notification, leaving only stack.maxOpen from
                // the stack.
                notice.close(false);
                return false;
              }
            });
          } else if (stack.maxStrategy === 'wait') {
            _state = 'waiting';
            return;
          } else {
            throw new Error(`Bad stack maxStrategy option: ${stack.maxStrategy}`);
          }
        }
      }
    }

    _state = 'opening';
    // This makes the notice visibity: hidden; so its dimensions can be
    // determined.
    _animatingClass = 'ui-pnotify-initial-hidden';
    runModules('beforeOpen');

    const afterOpenCallback = () => {
      // Now set it to hide.
      if (hide) {
        queueClose();
      }

      _state = 'open';

      runModules('afterOpen');
    };

    if (stack) {
      // Notify the stack that a notice has opened.
      stack._handleNoticeOpened(self);
    }

    if (_moduleIsNoticeOpen) {
      afterOpenCallback();
      return;
    }

    // If the notice is not in the DOM, or in the wrong context, append it.
    if (
      refs.elem &&
      !refs.elem.parentNode ||
      (
        stack &&
        stack.context &&
        stack.context !== refs.elem.parentNode
      )
    ) {
      if (stack && (stack.context || document.body)) {
        if (!stack.context) {
          stack.context = document.body;
        }
        stack.context.appendChild(refs.elem);
      } else {
        throw new Error('No context to open this notice in.');
      }
    }

    // Wait until the DOM is updated.
    window.requestAnimationFrame(() => {
      if (stack) {
        // Mark the stack so it won't animate the new notice.
        stack._animation = false;
        // Now position the stack's the notices.
        stack.position();
        // Reset animation.
        stack._animation = true;
      }

      animateIn(afterOpenCallback);
    });
  };

  // Remove the notice.
  export let close = (timerHide, waitAfterward) => {
    if (_state === 'closing' || _state === 'closed') {
      return;
    }

    const runDestroy = () => {
      runModules('beforeDestroy');
      if (stack) {
        stack._removeNotice(self);
      }
      self.$destroy();
      runModules('afterDestroy');
      runModules('$destroy');
    };

    if (_state === 'waiting') {
      _state = 'closed';
      // It's debatable whether the notice should be destroyed in this case, but
      // I'm going to go ahead and say yes.
      if (destroy && !waitAfterward) {
        runDestroy();
      }
      return;
    }

    _state = 'closing';
    _timerHide = !!timerHide; // Make sure it's a boolean.
    runModules('beforeClose');

    if (_timer && _timer !== 'prevented' && clearTimeout) {
      clearTimeout(_timer);
      _timer = null;
    }
    animateOut(() => {
      _timerHide = false;
      _state = waitAfterward ? 'waiting' : 'closed';
      runModules('afterClose');
      if (destroy && !waitAfterward) {
        // If we're supposed to destroy the notice, run the destroy module
        // events, remove from notices array, and let Svelte handle DOM removal.
        runDestroy();
      } else if (remove && !waitAfterward) {
        // If we're supposed to remove the notice from the DOM, do it.
        refs.elem && refs.elem.parentNode.removeChild(refs.elem);
      }
      if (stack) {
        stack._handleNoticeClosed(self);
      }
    });
  };

  // Animate the notice in.
  export let animateIn = async callback => {
    // Declare that the notice is animating in.
    _animating = 'in';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'in') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (visible) {
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade') {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // eslint-disable-next-line no-unused-expressions
      refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.
      _animatingClass = 'ui-pnotify-in ui-pnotify-fade-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = 'ui-pnotify-in';
      await tick();
      finished();
    }
  };

  // Animate the notice out.
  export let animateOut = async callback => {
    // Declare that the notice is animating out.
    _animating = 'out';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'out') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === '0' || !visible) {
        _animatingClass = '';
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        // In case this was called before the notice finished animating.
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade') {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = '';
      await tick();
      finished();
    }
  };

  // Position the notice.
  export function position () {
    // Get the notice's stack.
    let elem = refs.elem;
    if (!stack || !elem) {
      return;
    }
    if (typeof stack._nextpos1 !== 'number') {
      stack._nextpos1 = stack.firstpos1;
    }
    if (typeof stack._nextpos2 !== 'number') {
      stack._nextpos2 = stack.firstpos2;
    }
    if (typeof stack._addpos2 !== 'number') {
      stack._addpos2 = 0;
    }

    // Skip this notice if it's not shown.
    if (
      !elem.classList.contains('ui-pnotify-in') &&
      !elem.classList.contains('ui-pnotify-initial-hidden')
    ) {
      return;
    }

    // Use local variables, since a masking notice position shouldn't update the
    // stack.
    let [firstpos1, firstpos2, _nextpos1, _nextpos2, _addpos2] = [
      stack.firstpos1,
      stack.firstpos2,
      stack._nextpos1,
      stack._nextpos2,
      stack._addpos2
    ];

    // Read from the DOM to cause refresh.
    elem.getBoundingClientRect();

    if (stack._animation && !_masking) {
      // Add animate class.
      _moveClass = 'ui-pnotify-move';
    }

    let spaceY = (stack.context === document.body ? window.innerHeight : stack.context.scrollHeight);
    let spaceX = (stack.context === document.body ? window.innerWidth : stack.context.scrollWidth);

    let csspos1;

    if (stack.dir1) {
      csspos1 = {
        down: 'top',
        up: 'bottom',
        left: 'right',
        right: 'left'
      }[stack.dir1];

      // Calculate the current pos1 value.
      let curpos1;
      switch (stack.dir1) {
        case 'down':
          curpos1 = elem.offsetTop;
          break;
        case 'up':
          curpos1 = spaceY - elem.scrollHeight - elem.offsetTop;
          break;
        case 'left':
          curpos1 = spaceX - elem.scrollWidth - elem.offsetLeft;
          break;
        case 'right':
          curpos1 = elem.offsetLeft;
          break;
      }
      // Remember the first pos1, so the first notice goes there.
      if (typeof firstpos1 === 'undefined') {
        firstpos1 = curpos1;
        _nextpos1 = firstpos1;
      }
    }

    if (stack.dir1 && stack.dir2) {
      let csspos2 = {
        down: 'top',
        up: 'bottom',
        left: 'right',
        right: 'left'
      }[stack.dir2];

      // Calculate the current pos2 value.
      let curpos2;
      switch (stack.dir2) {
        case 'down':
          curpos2 = elem.offsetTop;
          break;
        case 'up':
          curpos2 = spaceY - elem.scrollHeight - elem.offsetTop;
          break;
        case 'left':
          curpos2 = spaceX - elem.scrollWidth - elem.offsetLeft;
          break;
        case 'right':
          curpos2 = elem.offsetLeft;
          break;
      }
      // Remember the first pos2, so the first notice goes there.
      if (typeof firstpos2 === 'undefined') {
        firstpos2 = curpos2;
        _nextpos2 = firstpos2;
      }

      // Check that it's not beyond the viewport edge.
      const endY = _nextpos1 + elem.offsetHeight + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
      const endX = _nextpos1 + elem.offsetWidth + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
      if (
        ((stack.dir1 === 'down' || stack.dir1 === 'up') && endY > spaceY) ||
        ((stack.dir1 === 'left' || stack.dir1 === 'right') && endX > spaceX)
      ) {
        // If it is, it needs to go back to the first pos1, and over on pos2.
        _nextpos1 = firstpos1;
        _nextpos2 += _addpos2 + (typeof stack.spacing2 === 'undefined' ? 25 : stack.spacing2);
        _addpos2 = 0;
      }

      // Move the notice on dir2.
      if (typeof _nextpos2 === 'number') {
        elem.style[csspos2] = _nextpos2 + 'px';
        if (!stack._animation) {
          // eslint-disable-next-line no-unused-expressions
          elem.style[csspos2]; // Read from the DOM for update.
        }
      }

      // Keep track of the widest/tallest notice in the column/row, so we can push the next column/row.
      switch (stack.dir2) {
        case 'down':
        case 'up':
          if (elem.offsetHeight + (parseFloat(elem.style.marginTop, 10) || 0) + (parseFloat(elem.style.marginBottom, 10) || 0) > _addpos2) {
            _addpos2 = elem.offsetHeight;
          }
          break;
        case 'left':
        case 'right':
          if (elem.offsetWidth + (parseFloat(elem.style.marginLeft, 10) || 0) + (parseFloat(elem.style.marginRight, 10) || 0) > _addpos2) {
            _addpos2 = elem.offsetWidth;
          }
          break;
      }
    } else if (stack.dir1) {
      // Center the notice along dir1 axis, because the stack has no dir2.
      let cssMiddle, cssposCross;
      switch (stack.dir1) {
        case 'down':
        case 'up':
          cssposCross = ['left', 'right'];
          cssMiddle = (stack.context.scrollWidth / 2) - (elem.offsetWidth / 2);
          break;
        case 'left':
        case 'right':
          cssposCross = ['top', 'bottom'];
          cssMiddle = (spaceY / 2) - (elem.offsetHeight / 2);
          break;
      }
      elem.style[cssposCross[0]] = cssMiddle + 'px';
      elem.style[cssposCross[1]] = 'auto';
      if (!stack._animation) {
        // eslint-disable-next-line no-unused-expressions
        elem.style[cssposCross[0]]; // Read from the DOM for update.
      }
    }

    if (stack.dir1) {
      // Move the notice on dir1.
      if (typeof _nextpos1 === 'number') {
        elem.style[csspos1] = _nextpos1 + 'px';
        if (!stack._animation) {
          // eslint-disable-next-line no-unused-expressions
          elem.style[csspos1]; // Read from the DOM for update.
        }
      }

      // Calculate the next dir1 position.
      switch (stack.dir1) {
        case 'down':
        case 'up':
          _nextpos1 += elem.offsetHeight + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
          break;
        case 'left':
        case 'right':
          _nextpos1 += elem.offsetWidth + (typeof stack.spacing1 === 'undefined' ? 25 : stack.spacing1);
          break;
      }
    } else {
      // Center the notice on the screen, because the stack has no dir1.
      let cssMiddleLeft = (spaceX / 2) - (elem.offsetWidth / 2);
      let cssMiddleTop = (spaceY / 2) - (elem.offsetHeight / 2);
      elem.style.left = cssMiddleLeft + 'px';
      elem.style.top = cssMiddleTop + 'px';
      if (!stack._animation) {
        // eslint-disable-next-line no-unused-expressions
        elem.style.left; // Read from the DOM for update.
      }
    }

    // If we're not positioning a masking notice, update the stack properties.
    if (!_masking) {
      stack.firstpos1 = firstpos1;
      stack.firstpos2 = firstpos2;
      stack._nextpos1 = _nextpos1;
      stack._nextpos2 = _nextpos2;
      stack._addpos2 = _addpos2;
    }
  }

  // Cancel any pending removal timer.
  export function cancelClose () {
    if (_timer && _timer !== 'prevented') {
      clearTimeout(_timer);
    }
    if (_animTimer) {
      clearTimeout(_animTimer);
    }
    if (_state === 'closing') {
      // If it's animating out, stop it.
      _state = 'open';
      _animating = false;
      _animatingClass = animation === 'fade' ? 'ui-pnotify-in ui-pnotify-fade-in' : 'ui-pnotify-in';
    }
  }

  // Queue a close timer.
  export function queueClose () {
    if (_timer === 'prevented') {
      return;
    }
    // Cancel any current close timer.
    cancelClose();
    _timer = setTimeout(() => close(true), (isNaN(delay) ? 0 : delay));
  }

  export function preventTimerClose (prevent) {
    if (prevent) {
      cancelClose();
      _timer = 'prevented';
    } else if (_timer === 'prevented') {
      _timer = null;
      if (_state === 'open' && hide) {
        queueClose();
      }
    }
  }

  export function fire (name, detail) {
    dispatch(name, detail);
  }

  export function addModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        _moduleClasses[element].push(className);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function removeModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      const idx = _moduleClasses[element].indexOf(className);
      if (idx !== -1) {
        _moduleClasses[element].splice(idx, 1);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function hasModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        return false;
      }
    }
    return true;
  }

  export function getModuleAccessors () {
    return _moduleAccessors;
  }

  export function getModuleIsNoticeOpen () {
    return _moduleIsNoticeOpen;
  }

  export function setModuleIsNoticeOpen (value) {
    return _moduleIsNoticeOpen = value;
  }

  export function setAnimating (value) {
    return _animating = value;
  }

  export function getAnimatingClass () {
    return _animatingClass;
  }

  export function setAnimatingClass (value) {
    return _animatingClass = value;
  }

  export function setMasking (value) {
    if (value) {
      _animatingClass = 'ui-pnotify-initial-hidden';
      // Wait for the DOM to update.
      window.requestAnimationFrame(() => {
        _masking = true;
        position();
        _animatingClass = '';
      })
    } else {
      _masking = false;
    }
  }
</script>

<style>
  /* -- Notice */
  :global(body > .ui-pnotify) {
    /* Notices in the body context should be fixed to the viewport. */
    position: fixed;
    /* Ensures notices are above everything */
    z-index: 100040;
  }
  :global(body > .ui-pnotify.ui-pnotify-modal) {
    z-index: 100042;
  }
  :global(.ui-pnotify) {
    position: absolute;
    height: auto;
    z-index: 1;
    display: none;
    transition: opacity .1s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-modal) {
    z-index: 3;
  }
  :global(.ui-pnotify.ui-pnotify-in) {
    display: block;
    opacity: 1;
  }
  :global(.ui-pnotify.ui-pnotify-initial-hidden) {
    display: block;
    visibility: hidden;
  }
  :global(.ui-pnotify.ui-pnotify-move) {
    transition: left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow) {
    transition: opacity .4s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move) {
    transition: opacity .4s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal) {
    transition: opacity .25s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move) {
    transition: opacity .25s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast) {
    transition: opacity .1s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move) {
    transition: opacity .1s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-masking) {
    display: block;
    opacity: 1;
    -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
    mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
  }
  :global(.ui-pnotify.ui-pnotify-fade-in) {
    opacity: 1;
  }
  :global(.ui-pnotify .ui-pnotify-shadow) {
    -webkit-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    -moz-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
  }
  :global(.ui-pnotify-container) {
    background-position: 0 0;
    padding: .8em;
    height: 100%;
    margin: 0;
  }
  :global(.ui-pnotify-container:after) {
    content: " "; /* Older browser do not support empty content */
    visibility: hidden;
    display: block;
    height: 0;
    clear: both;
  }
  :global(.ui-pnotify-container.ui-pnotify-sharp) {
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
  }
  :global(.ui-pnotify-title) {
    display: block;
    white-space: pre-line;
    margin-bottom: .4em;
    margin-top: 0;
  }
  :global(.ui-pnotify.ui-pnotify-with-icon .ui-pnotify-content) {
    margin-left: 24px;
  }
  :global([dir=rtl] .ui-pnotify.ui-pnotify-with-icon .ui-pnotify-content) {
    margin-right: 24px;
    margin-left: 0;
  }
  /* Bootstrap 4: make title text a tad smaller. */
  :global(.ui-pnotify .bootstrap4-title) {
    font-size: 1.2rem;
  }
  :global(.ui-pnotify-pre-line) {
    white-space: pre-line;
  }
  :global(.ui-pnotify-icon),
  :global(.ui-pnotify-icon span) {
    display: block;
    float: left;
  }
  :global([dir=rtl] .ui-pnotify-icon),
  :global([dir=rtl] .ui-pnotify-icon span) {
    float: right;
  }
  /* Bootstrap 3: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap3-icon > span) {
    position: relative;
    top: 2px;
  }
  /* Bootstrap 4: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap4-icon > span) {
    position: relative;
    top: 4px;
  }
  /* Overlay */
  :global(.ui-pnotify-modal-overlay) {
    background-color: rgba(0, 0, 0, .6);
    top: 0;
    left: 0;
    position: absolute;
    height: 100%;
    width: 100%;
    z-index: 2;
    transition: opacity .075s linear;
    opacity: 0;
    display: flex;
    justify-content: center;
    align-items: flex-end;
  }
  :global(.ui-pnotify-modal-overlay.ui-pnotify-modal-overlay-in) {
    opacity: 1;
  }
  :global(.ui-pnotify-modal-overlay-closes:after) {
    content: "×";
    font-family: Arial;
    font-size: 3rem;
    color: #fff;
    text-shadow: 0 0 .4rem #FFF;
  }
  :global(body > .ui-pnotify-modal-overlay) {
    position: fixed;
    z-index: 100041;
  }
</style>
